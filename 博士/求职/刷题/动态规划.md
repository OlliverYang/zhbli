#### 322. 零钱兑换

> 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的**最少的硬币个数**。如果没有任何一种硬币组合能组成总金额，返回 -1。

```python
dp[i] = x：当目标金额为 i 时，至少需要 x 枚硬币。
dp[i] = min{dp[i-coin] + 1}
```

#### 518. 零钱兑换 II

> 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的**硬币组合数**。假设每一种面额的硬币有无限个。 

```python
dp[i][j]：使用前 i 个硬币，若想凑数金额 j，有 dp[i][j] 种凑法。
dp[i][j] = dp[i - 1][j]        # 不使用硬币 i
         + dp[i][j-coins[i-1]] # 使用硬币 i
```

#### 416. 分割等和子集

> 给定一个**只包含正整数**的**非空**数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

转换为背包问题：给一个可装载重量为 `sum / 2` 的背包和 `N` 个物品，每个物品的重量为 `nums[i]`。现在让你装物品，是否存在一种装法，能够恰好将背包装满？

```python
dp[i][j] = True or False 表示: 当前背包的容量为 j 时，使用前 i 个物品，是否有一种方法恰好将背包装满。
dp[i][j] = dp[i-1][j]        # 不使用第 i 个物品
        or dp[i][j-nums[i]]  # 使用第 i 个物品
```

#### 300. 最长上升子序列

> 给定一个无序的整数数组，找到其中最长递增子序列的长度。

```python
dp[i]：以 nums[i] 这个数结尾的最长递增子序列的长度。
dp[i] = max(dp[j]) + 1, 其中 0 <= j <= i, nums[j] < nums[i]
```

####  53. 最大子序和

> 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```python
dp[i]: 以 nums[i] 为结尾的最大子数组和
dp[i] = max(nums[i],              # 不与前面的子数组连接，自成一派，自己作为一个子数组
            nums[i] + dp[i - 1])  # 与前面的相邻子数组连接，形成一个和更大的子数组
```

#### 0-1 背包问题

> 给你一个可装载重量为 `W` 的背包和 `N` 个物品，每个物品有重量和价值两个属性。其中第 `i` 个物品的重量为 `wt[i]`，价值为 `val[i]`，现在让你用这个背包装物品，最多能装的价值是多少？

```python
dp[i][j]: 使用前 i 个物品，当前背包的容量为 j，这种情况下可以装的最大价值是 dp[i][j]
dp[i][j] = max(dp[i-1][j],                   # 不把物品 i 装进背包
               dp[i-1][j - wt[i]] + val[i])  # 把物品 i 装进背包
```

####  编辑距离

> 给你两个单词 *word1* 和 *word2*，请你计算出将 *word1* 转换成 *word2* 所使用的最少操作数 。
> 你可以对一个单词（仅指word1）进行如下三种操作：
>
> 1. 插入一个字符
> 2. 删除一个字符
> 3. 替换一个字符

```python
dp[i][j]: 对于 str1[0...i] 和 str2[0...j]，它们的最小编辑距离 dp[i][j]。
if str1[i] == str2[j]:
    dp[i][j] = dp[i - 1][j - 1]		
else               
	dp[i][j] = min(dp[i - 1][j] + 1,  # 删除 str1[i]
                   dp[i][j - 1] + 1,  # 插入 str1[i]，则插入后两个字符串的结尾相等
                   dp[i-1][j-1] + 1)  # 替换 str1[i]，则替换后两个字符串的结尾相等
```

#### 1312. 让字符串成为回文串的最少插入次数

```python
dp[i][j]: s[i...j] 转为回文串的最小插入次数
if 最左、最右两个字符相同:
    dp[i][j] = dp[i+1][j-1]  
else:
    dp[i][j] = min(dp[i+1][j], dp[i][j-1])
```

#### 最长公共子序列

```python
dp[i][j]: 对于 str1[0...i] 和 str2[0...j]，它们的 LCS 长度是 dp[i][j]。
if str1[i] == str2[j]:
    dp[i][j] = 1 + dp[i-1][j-1]
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

#### 高楼扔鸡蛋

> 你面前有一栋从 1 到 `N` 共 `N` 层的楼，然后给你 `K` **个**鸡蛋（`K` 至少为 1）。现在确定这栋楼存在楼层 `0 <= F <= N`，在这层楼将鸡蛋扔下去，鸡蛋**恰好没摔碎**（高于 `F` 的楼层都会碎，低于 `F` 的楼层都不会碎）。现在问你，**最坏**情况下，你**至少**要扔几**次**鸡蛋，才能**确定**这个楼层 `F` 呢？

```python
状态：
	当前拥有的鸡蛋数 K 和需要测试的楼层数 N
选择：
	去选择哪层楼扔鸡蛋
状态转移：
	我们选择在第 i 层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。注意，这时候状态转移就来了：
    如果鸡蛋碎了，那么鸡蛋的个数 K 应该减一，搜索的楼层区间应该从 [1..N] 变为 [1..i-1] 共 i-1 层楼；
    如果鸡蛋没碎，那么鸡蛋的个数 K 不变，搜索的楼层区间应该从 [1..N] 变为 [i+1..N] 共 N-i 层楼。
dp[K][N]: 当前状态为 K 个鸡蛋，面对 N 层楼，返回这个状态下最少的扔鸡蛋次数。
```

<img src="https://labuladong.github.io/ebook/pictures/%E6%89%94%E9%B8%A1%E8%9B%8B/formula1.png" alt="img" style="zoom:50%;" />

#### 312. 戳气球

> 有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。
>
> 现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。
>
> 求所能获得硬币的最大数量。

```python
dp[i][j] = x: 戳破气球 i 和气球 j 之间（开区间，不包括 i 和 j）的所有气球，可以获得的最高分数为 x。
状态：i, j。
选择：最后戳破的那个气球 k。
dp[i][j] = max(dp[i][j],
               dp[i][k] + dp[k][j] + points[i]*points[j]*points[k])  # 你不是要最后戳破气球 k 吗？那得先把开区间 (i, k) 的气球都戳破，再把开区间 (k, j) 的气球都戳破；最后剩下的气球 k，相邻的就是气球 i 和气球 j，这时候戳破 k 的话得到的分数就是 points[i]*points[k]*points[j]。
```

#### 44. 通配符匹配

> 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。
>
> '?' 可以匹配任何单个字符。
> '*' 可以匹配任意字符串（包括空字符串）。
> 两个字符串完全匹配才算匹配成功。

```python
first = 第一个字符是否匹配
if 发现 '*':
	dp[i][j] = dp[i][j + 2] or (first and dp[i + 1][j])
else:
	dp[i][j] = dp[i + 1][j + 1]
```

#### 823. 带因子的二叉树

> 给出一个含有不重复整数元素的数组，每个整数均大于 1。
>
> 我们用这些整数来构建二叉树，每个整数可以使用任意次数。
>
> 其中：每个非叶结点的值应等于它的两个子结点的值的乘积。
>
> 满足条件的二叉树一共有多少个？返回的结果应模除 10 ** 9 + 7。

dp[i]：以 A[i] 为树根的树的种类数。

如果树根节点有孩子 x 和 y 满足 x * y == i，那么就有 dp(x) * dp(y) 种方法构造这棵树。

总共会有 $\sum_{x * y = v} \text{dp}(x) * \text{dp}(y)$ 种方法构造以 `v` 为根的树。

#### 1335. 工作计划的最低难度

> 你需要制定一份 d 天的工作计划表。工作之间存在依赖，要想执行第 i 项工作，你必须完成全部 j 项工作（ 0 <= j < i）。
>
> 你每天 至少 需要完成一项任务。工作计划的总难度是这 d 天每一天的难度之和，而一天的工作难度是当天应该完成工作的最大难度。
>
> 给你一个整数数组 jobDifficulty 和一个整数 d，分别代表工作难度和需要计划的天数。第 i 项工作的难度是 jobDifficulty[i]。
>
> 返回整个工作计划的 最小难度 。如果无法制定工作计划，则返回 -1 。
>

```python
dp[i][j]: [0...i] 天完成工作[0...j] 的最小难度。
dp[i][j] = min(dp[i-1][k] + min(jobDifficulty[k+1...j]))  min(难度(前i-1天完成工作[0...k]，第i天完成[k+1...j]))
k的限制：由于每天至少要完成一项工作，所以k<j
求：dp[d-1][len(jobDifficulty)-1]
```

