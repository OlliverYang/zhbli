#### 695. 岛屿的最大面积

> 给定一个包含了一些 0 和 1 的非空二维数组 grid 。
>
> 一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
>
> 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。

注意：扫描过一个点后，将其置零，避免再次访问。

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        area = -1
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                area = max(area, self.dfs(grid, i, j))
        return area

    def dfs(self, grid, i, j):
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):
            return 0
        flag = grid[i][j]
        if flag == 0:
            return 0
        else:
            grid[i][j] = 0
            return 1 + self.dfs(grid, i-1, j) + self.dfs(grid, i+1, j)
                     + self.dfs(grid, i, j-1) + self.dfs(grid, i, j+1)
```

#### 784. 字母大小写全排列

> 给定一个字符串`S`，通过将字符串`S`中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

```python
class Solution:
    def letterCasePermutation(self, S: str) -> List[str]:
        res = []

        def dfs(S, index):
            if len(S) == index:
                res.append(S[:])
                return

            s = S[index]
            dfs(S, index + 1)
            if not (S[index] >= '0' and s <= '9'):
                S[index] = chr(ord(s) ^ ord(' '))
                dfs(S, index + 1)

        dfs(list(S), 0)
        return [''.join(i) for i in res]
```

#### 面试题 08.10. 颜色填充

> 编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。
>
> 待填充的图像用二维数组 image 表示，元素为初始颜色值。初始坐标点的横坐标为 sr 纵坐标为 sc。需要填充的新颜色为 newColor 。
>
> 「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。
>
> 请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。
>

```python
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        originColor = image[sr][sc]
        def dfs(sr, sc):
            if sr < 0 or sc < 0 or sr >= len(image) or sc >= len(image[0]):
                return
            if image[sr][sc] == originColor:
                image[sr][sc] = -1
            else:
                return
            dfs(sr-1, sc)
            dfs(sr+1, sc)
            dfs(sr, sc-1)
            dfs(sr, sc+1)
        
        dfs(sr, sc)
        for i in range(len(image)):
            for j in range(len(image[0])):
                if image[i][j] == -1:
                    image[i][j] = newColor
        return image
```

#### 841. 钥匙和房间

> 有 `N` 个房间，开始时你位于 `0` 号房间。每个房间有不同的号码：`0，1，2，...，N-1`，并且房间里可能有一些钥匙能使你进入下一个房间。
>
> 在形式上，对于每个房间 `i` 都有一个钥匙列表 `rooms[i]`，每个钥匙 `rooms[i][j]` 由 `[0,1，...，N-1]` 中的一个整数表示，其中 `N = rooms.length`。 钥匙 `rooms[i][j] = v` 可以打开编号为 `v` 的房间。
>
> 最初，除 `0` 号房间外的其余所有房间都被锁住。
>
> 你可以自由地在房间之间来回走动。
>
> 如果能进入每个房间返回 `true`，否则返回 `false`。

```python
dfs(房间)：
	for 可打开的房间 in 房间：
    	dfs(可打开的房间)
```

#### 529. 扫雷游戏

> 让我们一起来玩扫雷游戏！
>
> 给定一个代表游戏板的二维字符矩阵。 **'M'** 代表一个**未挖出的**地雷，**'E'** 代表一个**未挖出的**空方块，**'B'** 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的**已挖出的**空白方块，**数字**（'1' 到 '8'）表示有多少地雷与这块**已挖出的**方块相邻，**'X'** 则表示一个**已挖出的**地雷。
>
> 现在给出在所有**未挖出的**方块中（'M'或者'E'）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：
>
> 1. 如果一个地雷（'M'）被挖出，游戏就结束了- 把它改为 **'X'**。
> 2. 如果一个**没有相邻地雷**的空方块（'E'）被挖出，修改它为（'B'），并且所有和其相邻的方块都应该被递归地揭露。
> 3. 如果一个**至少与一个地雷相邻**的空方块（'E'）被挖出，修改它为数字（'1'到'8'），表示相邻地雷的数量。
> 4. 如果在此次点击中，若无更多方块可被揭露，则返回面板。

### 图

#### 547. 朋友圈

> 班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。
>
> 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。
>

考点：图的深度优先搜索，求连通块数。

```python
def dfs(图的一个点i):
	for 图中的任一点 j:
        if i，j 相连且 j 未被访问：
        	j 已访问
            dfs(j)
def main():
    for 图中的任一点 k：
    	if k 未被访问：
        	dfs(k)
            连通块数+1
```

#### 207. 课程表

> 你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。
>
> 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]
>
> 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？

考点：图的深度优先搜索，判断是否存在环。

```python
def dfs(图中的一个点i):  # 返回：是否发现环
def main():
    for 图中的任一点 k:
        是否有环 = dfs(k, 每个节点的访问状态)
```

