### 深度优先搜索

#### 面试题 04.04. 检查平衡性

> 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。

```python
class Solution:
    def tree_height(self, root):
            if root is None:
                return 0
            return 1 + max(self.tree_height(root.left), self.tree_height(root.right))

    def isBalanced(self, root: TreeNode) -> bool:
        if root is None:
            return True
        left_height = self.tree_height(root.left)
        right_height = self.tree_height(root.right)
        if -1 <= left_height - right_height <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right):
            return True
        else:
            return False
```

#### 100. 相同的树

> 给定两个二叉树，编写一个函数来检验它们是否相同。
>
> 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

```python
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if p is None or q is None:
            if not (p is None and q is None):
                return False
            else:
                return True
        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

#### 101. 对称二叉树

> 给定一个二叉树，检查它是否是镜像对称的。

```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if root is None:
            return True
        left = root.left
        right = root.right
        def dfs(root1, root2):
            if root1 is None and root2 is None:
                return True
            if root1 is None or root2 is None:
                return False
            return root1.val == root2.val and dfs(root1.left, root2.right) and dfs(root1.right, root2.left)
        return dfs(left, right)
```

#### 104. 二叉树的最大深度

> 给定一个二叉树，找出其最大深度。
>
> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
> **说明:** 叶子节点是指没有子节点的节点。

```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```

### 广度优先搜索

#### 111. 二叉树的最小深度

> 给定一个二叉树，找出其最小深度。
>
> 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
>
> **说明:** 叶子节点是指没有子节点的节点。

```python
from collections import deque
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        depth = 1
        queue = deque([root])
        while queue:
            length = len(queue)
            for i in range(length):
                node = queue.popleft()
                if node.left is None and node.right is None:
                    return depth
                if node.left is not None:
                    queue.append(node.left)
                if node.right is not None:
                    queue.append(node.right)
            depth += 1
        return depth
```

