#### 回溯算法的框架

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

**解决一个回溯问题，实际上就是一个决策树的遍历过程**。你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

#### 51 N皇后

> n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
>
> 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。
>
> 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res = []
        board = [['.'] * n for i in range(n)]

        def isValid(board, row, col):
            n = len(board)
            # 检查列是否有皇后互相冲突
            for i in range(n):
                if board[i][col] == 'Q':
                    return False
            # 检查右上方是否有皇后互相冲突
            x = row - 1
            y = col + 1
            while x >= 0 and y < n:
                if board[x][y] == 'Q':
                    return False
                x -= 1
                y += 1
            # 检查左上方是否有皇后互相冲突
            x = row - 1
            y = col - 1
            while y >= 0 and x >= 0:
                if board[x][y] == 'Q':
                    return False
                x -= 1
                y -= 1
            return True

        def backtrack(board, row):
            # 触发结束条件
            if row == len(board):
                tmp = [''.join(i) for i in board]
                res.append(tmp)
                return
            for col in range(len(board[0])):
                #  排除不合法选择
                if not isValid(board, row, col):
                    continue
                # 做选择
                board[row][col] = 'Q'
				# 进入下一行决策
                backtrack(board, row + 1)
                # 撤销选择
                board[row][col] = '.'

        backtrack(board, 0)
        return res
```

#### 78 子集

> 给定一组**不含重复元素**的整数数组 *nums*，返回该数组所有可能的子集（幂集）。
>
> **说明：**解集不能包含重复的子集。

```python
def subsets(self, nums: List[int]) -> List[List[int]]:
    res = []
    def backtrack(track, nums):
        res.append(track[:])  # 必须加[:]
        for i, num in enumerate(nums):
            '''做选择'''
            track.append(num)
            '''回溯'''
            backtrack(track, nums[i+1:])
            '''撤销选择'''
            track.pop()
        backtrack([], nums)
        return res
```

#### 全排列

```python
def permute(nums='123'):
    res = []
    def backtrack(track, nums):
        if len(track) == len(nums):
            res.append(track)
            return
        for num in nums:
            if num in track:
                continue
            '''做选择'''
            track += num
            '''回溯'''
            backtrack(track, nums)
            '''撤销选择'''
            track = track[:-1]
    backtrack('', nums)
    return res
```

#### 491. 递增子序列

> 给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

```python
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        self.res = []
        def backtrack(track, nums):
            '''失败条件'''
            if len(track) >= 2 and track[-1] < track[-2]:
                return
            '''成功条件'''
            if len(track) >= 2 and track not in self.res:
                self.res.append(track[:])
            '''遍历选择列表'''
            for i, num in enumerate(nums):
                '''做选择'''
                track.append(num)
                '''回溯'''
                backtrack(track, nums[i+1:])
                '''撤销选择'''
                track.pop()
        backtrack([], nums)
        return self.res
```

