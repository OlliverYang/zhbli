#### 752. 打开转盘锁

> 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为  '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。
>
> 锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。
>
> 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。
>
> 字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。
>

```python
from collections import deque
class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        def neighbors(node):
            for i in range(4):
                x = int(node[i])
                for d in (-1, 1):
                    y = (x + d) % 10
                    yield node[:i] + str(y) + node[i+1:]

        queue = deque(['0000'])
        visited = {'0000'}
        step = 0
        while queue:
            length = len(queue)
            for i in range(length):
                node = queue.popleft()
                if node in deadends:
                    continue
                if node == target:
                    return step
                for new_node in neighbors(node):
                    if new_node not in visited:
                        queue.append(new_node)
                        visited.add(new_node)
            step += 1
        return -1
```

#### 773. 滑动谜题

> 在一个 2 x 3 的板上（`board`）有 5 块砖瓦，用数字 `1~5` 来表示, 以及一块空缺用 `0` 来表示.
>
> 一次移动定义为选择 `0` 与一个相邻的数字（上下左右）进行交换.
>
> 最终当板 `board` 的结果是 `[[1,2,3],[4,5,0]]` 谜板被解开。
>
> 给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。

```python
import numpy as np
class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        board = np.array(board)
        row, col = board.shape
        target = np.array([[1,2,3],[4,5,0]])        
        def neighbors(board):
            neighbor_list = []
            i, j = np.where(board == 0)
            i = i[0]
            j = j[0]
            for m, n in ([-1,0], [1,0], [0,-1], [0,1]):
                x = i + m
                y = j + n
                if x < 0 or y < 0 or x >= row or y >= col:
                    continue
                new_board = board.copy()
                new_board[i, j] = board[x, y]
                new_board[x, y] = 0
                neighbor_list.append(new_board)
                del new_board
            return neighbor_list
        queue = collections.deque([board])
        visited = [board.tolist()]
        step = 0
        while queue:
            length = len(queue)
            for i in range(length):
                node = queue.popleft()
                if (node == target).all():
                    return step
                for new_node in neighbors(node):
                    if new_node.tolist() not in visited:
                        queue.append(new_node)
                        visited.append(new_node.tolist())
            step += 1
        return -1
```

