---
title: >-
  [arXiv2003] Know Your Surroundings Exploiting Scene Information for Object
  Tracking
date: 2020-05-13 16:48:28
tags:
- Tracking
mathjax: true
categories:
- [Tracking, Architecture]
---

# Know Your Surroundings: Exploiting Scene Information for Object Tracking

<img src="https://i.loli.net/2020/05/13/Zcw45BGfEJMyk8T.png" alt="image-20200513183142238" style="zoom:50%;" />

跟踪算法仅依赖目标表观难以区分近似物体. 本文提出的算法使得跟踪器具有感知目标周围的近似物体(即场景信息)的能力. 场景信息可以在帧之间传播, 从而有效的区分近似物体.

场景信息被表示为状态向量, 具体而言, 在每个空间位置, 设置一个状态向量, 用于编码每个局部区域是目标/背景/干扰物. 状态向量和表观信息一起用于确定目标位置.

注意, 状态向量不进行显式编码, 而是进行端到端训练.

状态向量可以在帧间传播.

传播的意义: 传播前为state vectors, 传播后是propagated state vectors. 传播前仅代表上一帧中目标/背景/干扰物的分布, 但是与当前帧并不能对齐. 因此需要利用上帧和当前帧图像提取运动信息并使得状态向量更适用于当前帧, 即补偿帧间运动.

由于局部区域中的物体是运动的, 因此利用 dense correspondence maps 在帧间传播对应的状态向量. 这种 dense correspondence maps 就是显式的运动信息.

当跟踪到目标之后, 用于表示场景信息的状态向量通过循环神经模块被更新. 更新的作用: 重置错误的状态向量, 或捕获新进入画面的干扰物.

- 跟踪结果指定了目标位置, 因此更新可以纠正状态向量中对目标位置的错误预测.
- 表观模型的输出即包含了干扰物, 因此更新可以捕获新的干扰物.

注意传播模块和更新模块的区别: 运行传播模块时, 还不知道当前帧中目标的位置. 而运行更新模块时, 已经预测到了目标位置. 因此需要利用目标位置校正状态向量.

# 算法概述

状态向量：具有每个区域的位置信息。

空间传播状态：对相邻两帧的运动进行补偿。

Propagation Module（公式1）

- 公式: $(\hat h_{t-1}, \xi_{t}) = \Pi(x_{t}, x_{t-1}, h_{t-1})$
- 作用：对相邻两帧的运动进行补偿。
- 输入：当前帧特征，上一帧特征，上一帧的 states。
- 输出：spatially propagated state，传播可靠性图。
- 算法
  1. 计算$\mathbf{CV}$: 即correspondence. 表示当前帧中任一位置, 与上一帧任一位置的相似性. 通过相关得到, 上一帧中的每个位置分别在当前帧的所有位置进行相关。 
  2. 计算$\phi(\mathbf{r'}, \mathbf{r})$
     - 输入: $\mathbf{CV_{r'}}(\mathbf{r}) \in \mathbb{R}^{W \times H}$
     - 网络结构: 两个卷积块
  3. 计算$\phi'(\mathbf{r'}, \mathbf{r})$
     - $\phi'(\mathbf{r'}, \mathbf{r}) = \frac{\exp(\phi(\mathbf{r'}, \mathbf{r}))}{\sum_{\mathbf{r''} \in \mathit \Omega}\exp(\phi(\mathbf{r'}, \mathbf{r''}))}$
  4. 计算$p(\mathbf{r'}|\mathbf{r})$
     - 将$\phi'$再送入两个卷积块，并在上帧位置上计算softmax
  5. 计算$\hat h_{t-1}^{\mathbf{r}}$
     - $\hat h_{t-1}^{\mathbf{r}} = \sum_{\mathbf{r'} \in \mathit{\Omega}}h_{t-1}^{\mathbf{r'}}p(\mathbf{r'}|\mathbf{r})$
  6. 计算$\xi_{t}^{\mathbf{r}}$
     - $\xi_{t}^{\mathbf{r}} = \sum_{\mathbf{r'} \in \mathit{\Omega}}p(\mathbf{r'|r})log(p(\mathbf{r'|r}))$
  7. 损失: 使用一个小的network head预测每个$\hat h_{t-1}^{\mathbf{r}}$属于背景还是目标, 计算 binary cross entry loss.

Predictor（公式2）

- 公式: $\varsigma_{t} = P(\hat h_{t-1}, \xi_{t}, s_{t})$
- 作用：综合考虑表观信息和场景信息，做最终判断。
- 输入：表观响应图，空间传播状态，传播可靠性图。
- 输出：置信得分。
- 网络结构: 将输入串接起来, 送到2个卷积块中, 得到输出.
- 损失: gt是以目标为中心的高斯.

State update（公式3）

- 公式: $h_{t} = \varPhi(\hat h_{t-1}, \varsigma_{t}, s_{t})$
- 作用：更新状态向量。
- 输入：空间传播状态，表观得分，最终得分。
- 输出：状态向量。
- 网络结构: 将$\varsigma_{t}, s_{t}$串接起来送入ConvGRU, $\hat h_{t-1}$是隐状态, 得到输出$h_{t}$. 
- 损失: 使用一个小的network head预测每个$h_{t}^{\mathbf{r}}$属于背景还是目标, 计算 binary cross entry loss.

# 3.1 Tracking with Scene Propagation

deep feature map: $x_{t} \in \mathbb{R}^{W \times H \times D}$

score map $s_{t} = \tau(x_{t}) \in \mathbb{R}^{W \times H}$

- 注意：通道数为 1。

spatial location $\mathbf{r} \in \mathit{\Omega}:=\{0, ..., W - 1\} \times \{0, ..., H -1\}$

likelihood of position $\mathbf{r}$ being the target center: $s_{t}(\mathbf{r})$

appearance model: $\tau$

- 作用：区分目标和背景。
- 输入：$x_{t}$。
- 输出：$s_{t}$。
- 注意：输入和输出的空间分辨率不变。

first frame traget box: $b_{0}$

state vectors $h \in \mathbb{R}^{W \times H \times S}$

- 可以编码一个cell对应于目标，背景还是干扰物。
- 在第一帧中使用网络 $\Upsilon$ 进行初始化：$h_{0} = \Upsilon(b_{0})$

$\Upsilon$

- 输出：单通道 label map，指定目标位置。
- 结构：两个卷积层。

S-dimensional state vector: $h^{\mathbf{r}}$

frame index: $t$

state propagation module $\Pi$

- $(\hat h_{t-1}, \xi_{t}) = \Pi(x_{t}, x_{t-1}, h_{t-1})$
- 作用：补偿目标与背景的运动。

spatially propagated state: $\hat h_{t-1}$

- 作用：补偿目标与背景的运动。

propagataion reliability map: $\xi \in \mathbb{R}^{W \times H}$

- 作用：表示状态传播的可靠性。

predictor module: $P$

- $\varsigma_{t} = P(\hat h_{t-1}, \xi_{t}, s_{t})$
- 作用：确定目标的最终位置

fused target confidence score: $\varsigma_{t}$

recurrent state update module: $\varPhi$

- $h_{t} = \varPhi(\hat h_{t-1}, \varsigma_{t}, s_{t})$
- 作用：重置错误状态向量/标记新进入的干扰物。

# 3.2 State propagation

probability distribution: $p$

- 作用：计算两帧之间的dence  correspondence。
- $p(\mathbf{r'}|\mathbf{r})$：当前帧位置$\mathbf{r}$来自于上一帧位置$\mathbf{r'}$的概率。作用：计算$\hat h_{t-1}^{\mathbf{r}}$。

4D cost volume: $\mathbf{CV} \in \mathbb R^{W \times H \times W \times H}$

- 作用：表示密集对应。包含了任意两个来自先前帧和当前帧的图像位置的匹配损失。
- $\mathbf{CV}(\mathbf{r'}, \mathbf{r})$的计算：计算以上一帧位置$\mathbf{r'}$为中心的$3 \times 3$窗口的特征与当前帧的位置$\mathbf{r}$的相关。
- 注意：对于每个位置，仅考虑有限的范围$d_{\max}$。

cost volume slice: $\mathbf{CV_{r'}}(\mathbf{r}) \in \mathbb{R}^{W \times H}$

- 作用：将其送入两个卷积块以获得$\phi(\mathbf{r'}, \mathbf{r})$。
- 注意, $\mathbf{r}$是变量.

matching cost: $\phi(\mathbf{r'}, \mathbf{r})$

- 一个数。

initial correspondence: $\phi'(\mathbf{r'}, \mathbf{r})$

- $\phi'(\mathbf{r'}, \mathbf{r}) = \frac{\exp(\phi(\mathbf{r'}, \mathbf{r}))}{\sum_{\mathbf{r''} \in \mathit \Omega}\exp(\phi(\mathbf{r'}, \mathbf{r''}))}$：遍历当前帧的每个位置以计算softmax。

- 作用：在当前帧维度上整合了信息，提供了两帧之间的位置的软关联。
- 注意：为了在先前帧的每个位置整合信息，将$\phi'$再送入两个卷积块，并在上帧位置上计算softmax。从而获得了$p(\mathbf{r'}|\mathbf{r})$。

$\hat h_{t-1}^{\mathbf{r}} = \sum_{\mathbf{r'} \in \mathit{\Omega}}h_{t-1}^{\mathbf{r'}}p(\mathbf{r'}|\mathbf{r})$

- $\mathbf{r}$：当前帧位置。
- 缺点：single mode 的 $p(\mathbf{r'|r})$ 说明可以很自信的从上一帧定位当前帧的位置$\mathbf{r}$，而如果$p(\mathbf{r'|r})$是均匀分布的，说明具有不确定性。仅仅对先前帧的状态向量$h_{t-1}^{\mathbf{r'}}$做了平均，因此不稳定。

$\xi_{t}^{\mathbf{r}} = \sum_{\mathbf{r'} \in \mathit{\Omega}}p(\mathbf{r'|r})log(p(\mathbf{r'|r}))$

- 使用 the negation of the shannon entropy 计算可靠性图。

<img src="https://i.loli.net/2020/05/13/mt6LkYDcQSfoxEs.png" alt="image-20200327144113990" style="zoom:50%;" />

问题

- 为什么不直接进行第二次softmax？反正结果一样.
- 是否能够保证$p(\mathbf{r'}|\mathbf{r})$之和为1? 可以.
  - $p(\mathbf{a}|\mathbf{A}) + p(\mathbf{b}|\mathbf{A}) + p(\mathbf{c}|\mathbf{A}) + p(\mathbf{d}|\mathbf{A}) = 0.1 + 0.2 + 0.3 + 0.4 = 1$

# 3.3 Target Confidence Score Prediction

propagated state vector: $\hat h_{t-1}^{\mathbf{r}}$

- 作用：包含了位置$\mathbf{r}$的过去的信息。比如，是否在先前帧中被分类为目标/背景，跟踪器在该位置预测的确信度，等等。

将表观$s_t$, 传播状态向量$\hat h_{t-1}$以及状态可靠性图$\xi_{t}$在通道维度串接起来，送到两个卷积块中，得到$\hat \varsigma_{t}$。

- 缺点：state vectors 难以处理遮挡。
- 方案：将$\hat \varsigma_{t}$传入另一个层，对于表观的分低于阈值的位置，在$\hat \varsigma_{t}$中进行mask。

$\varsigma_{t} = \hat \varsigma_{t} \cdot 1_{s_t > \mu}$

- 该操作是可微分的.

# 3.4 State update

update module $\varPhi$ 可以标记一个新进入场景的干扰物, 纠正一个错误传播的状态.

$\varPhi$ 由一个ConvGRU构成. 将得分$\varsigma_{t}$和表观$s_t$ along with their maximum values串接起来以获得输入$f_t \in \mathbb{R} ^{W \times H \times 4}$.

- 什么叫along with their maximum values? 为什么通道数是4?

来自$\hat h_{t-1}$的propagated states 被认为是ConvGRU的算个一个time step的隐状态.

# 3.5 Target Appearance Model

appearance model $\tau_w$

$L(w) = \frac{1}{|S_{train}|}\sum_{(x,c)\in S_{train}} ||r(\tau_w (x), c)||^2 + ||\lambda w||^2$

- $\lambda$: 正则化参数.
- $S_{train} = \{(x_i, c_j)\}_{j=1}^n$: 由深度特征图$x_j$和对应的标注$c_j$组成.
- 残差函数$r(s,c)$计算跟踪器的预测$s=\tau_w (x)$与groundtruth之间的误差.

# 3.6 Offine Training

prediction error: $L_t^{\text{pred}}$

- $L_t^{\text{pred}} = ||\varsigma_t - z_t||^2$

label funtion: $z_t$

- 以目标为中心的高斯.

prediction error: $L_t^{\text{pred, raw}}$

- 根据$\hat{\varsigma_t}$计算, 以获得额外的训练监督.

$L_{t}^{\text{state}}$

- 为了学习状态向量和传播模块, 增加了辅助任务: 使用了 small network head 预测一个状态向量$h_{t-1}^{\mathbf{r}}$对应于目标还是背景.
- 该预测通过binary cross entry loss进行惩罚, 从而计算$L_t^{\text{state}}$.
- 该network head同样应用到propagated state vectors $\hat h_{t-1}^{\mathbf{r}}$.

最终跟踪损失: $L $

- $L=\frac{1}{N_{\text{seq}}-1}\sum_{t-1}^{N_{\text{seq}}}L_t^{\text{pred}} + \alpha L_t^{\text{pred, raw}} + \beta(L_t^{\text{state}} + L_{t}^{\text{state, prop}})$

- $s_t$ 就能正确定位绝大多数目标, 因此可能进学习到仅依赖$s_t$进行预测. 因此随机在$s_t$上增加随机干扰峰值, 以鼓励学习由state vectors编码的场景信息.

# 3.7 Implementation details

使用(与表观模型共享的)ResNet-50的block 4特征作为状态传播模块$\varPi$的输入. 注意, 不对backbone进行微调.

$S = 8$ 以编码场景信息.